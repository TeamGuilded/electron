From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Chevonc <Chevonc@live.com>
Date: Tue, 15 Sep 2020 22:26:56 -0700
Subject: audio buffer patch from right commit


diff --git a/modules/audio_coding/acm2/audio_coding_module.cc b/modules/audio_coding/acm2/audio_coding_module.cc
index b68579b1cbacf2e31f60e72ba996c26b0d5d4df1..a2d08ac004ca7f3d54547a0ff781c726e9fc5119 100644
--- a/modules/audio_coding/acm2/audio_coding_module.cc
+++ b/modules/audio_coding/acm2/audio_coding_module.cc
@@ -11,7 +11,6 @@
 #include "modules/audio_coding/include/audio_coding_module.h"
 
 #include <assert.h>
-
 #include <algorithm>
 #include <cstdint>
 
@@ -38,6 +37,8 @@ namespace {
 // 48 kHz data.
 constexpr size_t kInitialInputDataBufferSize = 6 * 480;
 
+constexpr int32_t kMaxInputSampleRateHz = 192000;
+
 class AudioCodingModuleImpl final : public AudioCodingModule {
  public:
   explicit AudioCodingModuleImpl(const AudioCodingModule::Config& config);
@@ -64,14 +65,6 @@ class AudioCodingModuleImpl final : public AudioCodingModule {
   // Set target packet loss rate
   int SetPacketLossRate(int loss_rate) override;
 
-  /////////////////////////////////////////
-  //   (VAD) Voice Activity Detection
-  //   and
-  //   (CNG) Comfort Noise Generation
-  //
-
-  int RegisterVADCallback(ACMVADCallback* vad_callback) override;
-
   /////////////////////////////////////////
   //   Receiver
   //
@@ -132,7 +125,11 @@ class AudioCodingModuleImpl final : public AudioCodingModule {
 
   int Add10MsDataInternal(const AudioFrame& audio_frame, InputData* input_data)
       RTC_EXCLUSIVE_LOCKS_REQUIRED(acm_crit_sect_);
-  int Encode(const InputData& input_data)
+
+  // TODO(bugs.webrtc.org/10739): change |absolute_capture_timestamp_ms| to
+  // int64_t when it always receives a valid value.
+  int Encode(const InputData& input_data,
+             absl::optional<int64_t> absolute_capture_timestamp_ms)
       RTC_EXCLUSIVE_LOCKS_REQUIRED(acm_crit_sect_);
 
   int InitializeReceiverSafe() RTC_EXCLUSIVE_LOCKS_REQUIRED(acm_crit_sect_);
@@ -185,7 +182,6 @@ class AudioCodingModuleImpl final : public AudioCodingModule {
   rtc::CriticalSection callback_crit_sect_;
   AudioPacketizationCallback* packetization_callback_
       RTC_GUARDED_BY(callback_crit_sect_);
-  ACMVADCallback* vad_callback_ RTC_GUARDED_BY(callback_crit_sect_);
 
   int codec_histogram_bins_log_[static_cast<size_t>(
       AudioEncoder::CodecType::kMaxLoggedAudioCodecTypes)];
@@ -220,7 +216,6 @@ AudioCodingModuleImpl::AudioCodingModuleImpl(
       first_10ms_data_(false),
       first_frame_(true),
       packetization_callback_(NULL),
-      vad_callback_(NULL),
       codec_histogram_bins_log_(),
       number_of_consecutive_empty_packets_(0) {
   if (InitializeReceiverSafe() < 0) {
@@ -231,7 +226,11 @@ AudioCodingModuleImpl::AudioCodingModuleImpl(
 
 AudioCodingModuleImpl::~AudioCodingModuleImpl() = default;
 
-int32_t AudioCodingModuleImpl::Encode(const InputData& input_data) {
+int32_t AudioCodingModuleImpl::Encode(
+    const InputData& input_data,
+    absl::optional<int64_t> absolute_capture_timestamp_ms) {
+  // TODO(bugs.webrtc.org/10739): add dcheck that
+  // |audio_frame.absolute_capture_timestamp_ms()| always has a value.
   AudioEncoder::EncodedInfo encoded_info;
   uint8_t previous_pltype;
 
@@ -253,6 +252,7 @@ int32_t AudioCodingModuleImpl::Encode(const InputData& input_data) {
                     int64_t{input_data.input_timestamp - last_timestamp_} *
                         encoder_stack_->RtpTimestampRateHz(),
                     int64_t{encoder_stack_->SampleRateHz()}));
+
   last_timestamp_ = input_data.input_timestamp;
   last_rtp_timestamp_ = rtp_timestamp;
   first_frame_ = false;
@@ -302,12 +302,8 @@ int32_t AudioCodingModuleImpl::Encode(const InputData& input_data) {
     if (packetization_callback_) {
       packetization_callback_->SendData(
           frame_type, encoded_info.payload_type, encoded_info.encoded_timestamp,
-          encode_buffer_.data(), encode_buffer_.size());
-    }
-
-    if (vad_callback_) {
-      // Callback with VAD decision.
-      vad_callback_->InFrameType(frame_type);
+          encode_buffer_.data(), encode_buffer_.size(),
+          absolute_capture_timestamp_ms.value_or(-1));
     }
   }
   previous_pltype_ = encoded_info.payload_type;
@@ -337,7 +333,11 @@ int AudioCodingModuleImpl::RegisterTransportCallback(
 int AudioCodingModuleImpl::Add10MsData(const AudioFrame& audio_frame) {
   rtc::CritScope lock(&acm_crit_sect_);
   int r = Add10MsDataInternal(audio_frame, &input_data_);
-  return r < 0 ? r : Encode(input_data_);
+  // TODO(bugs.webrtc.org/10739): add dcheck that
+  // |audio_frame.absolute_capture_timestamp_ms()| always has a value.
+  return r < 0
+             ? r
+             : Encode(input_data_, audio_frame.absolute_capture_timestamp_ms());
 }
 
 int AudioCodingModuleImpl::Add10MsDataInternal(const AudioFrame& audio_frame,
@@ -348,7 +348,7 @@ int AudioCodingModuleImpl::Add10MsDataInternal(const AudioFrame& audio_frame,
     return -1;
   }
 
-  if (audio_frame.sample_rate_hz_ > 192000) {
+  if (audio_frame.sample_rate_hz_ > kMaxInputSampleRateHz) {
     assert(false);
     RTC_LOG(LS_ERROR) << "Cannot Add 10 ms audio, input frequency not valid";
     return -1;
@@ -465,20 +465,25 @@ int AudioCodingModuleImpl::PreprocessToAddData(const AudioFrame& in_frame,
   *ptr_out = &preprocess_frame_;
   preprocess_frame_.num_channels_ = in_frame.num_channels_;
   preprocess_frame_.samples_per_channel_ = in_frame.samples_per_channel_;
-  std::array<int16_t, WEBRTC_10MS_PCM_AUDIO> audio;
-  const int16_t* src_ptr_audio = in_frame.data();
+  std::array<int16_t, AudioFrame::kMaxDataSizeSamples> audio;
+  const int16_t* src_ptr_audio;
   if (down_mix) {
-    // If a resampling is required the output of a down-mix is written into a
+    // If a resampling is required, the output of a down-mix is written into a
     // local buffer, otherwise, it will be written to the output frame.
     int16_t* dest_ptr_audio =
         resample ? audio.data() : preprocess_frame_.mutable_data();
+    RTC_DCHECK_GE(audio.size(), preprocess_frame_.samples_per_channel_);
     RTC_DCHECK_GE(audio.size(), in_frame.samples_per_channel_);
     DownMixFrame(in_frame,
                  rtc::ArrayView<int16_t>(
                      dest_ptr_audio, preprocess_frame_.samples_per_channel_));
     preprocess_frame_.num_channels_ = 1;
-    // Set the input of the resampler is the down-mixed signal.
+
+    // Set the input of the resampler to the down-mixed signal.
     src_ptr_audio = audio.data();
+  } else {
+    // Set the input of the resampler to the original data.
+    src_ptr_audio = in_frame.data();
   }
 
   preprocess_frame_.timestamp_ = expected_codec_ts_;
@@ -583,13 +588,6 @@ int AudioCodingModuleImpl::GetNetworkStatistics(NetworkStatistics* statistics) {
   return 0;
 }
 
-int AudioCodingModuleImpl::RegisterVADCallback(ACMVADCallback* vad_callback) {
-  RTC_LOG(LS_VERBOSE) << "RegisterVADCallback()";
-  rtc::CritScope lock(&callback_crit_sect_);
-  vad_callback_ = vad_callback;
-  return 0;
-}
-
 bool AudioCodingModuleImpl::HaveValidEncoder(const char* caller_name) const {
   if (!encoder_stack_) {
     RTC_LOG(LS_ERROR) << caller_name << " failed: No send codec is registered.";
diff --git a/modules/audio_coding/include/audio_coding_module.h b/modules/audio_coding/include/audio_coding_module.h
index d8c926007704fbe9bae65bcf6babeee51512dac2..102e2de83b3a5476bb12668cedc3e3b72a8caca8 100644
--- a/modules/audio_coding/include/audio_coding_module.h
+++ b/modules/audio_coding/include/audio_coding_module.h
@@ -33,8 +33,6 @@ class AudioEncoder;
 class AudioFrame;
 struct RTPHeader;
 
-#define WEBRTC_10MS_PCM_AUDIO 960  // 16 bits super wideband 48 kHz
-
 // Callback class used for sending data ready to be packetized
 class AudioPacketizationCallback {
  public:
@@ -44,15 +42,21 @@ class AudioPacketizationCallback {
                            uint8_t payload_type,
                            uint32_t timestamp,
                            const uint8_t* payload_data,
-                           size_t payload_len_bytes) = 0;
-};
-
-// Callback class used for reporting VAD decision
-class ACMVADCallback {
- public:
-  virtual ~ACMVADCallback() {}
-
-  virtual int32_t InFrameType(AudioFrameType frame_type) = 0;
+                           size_t payload_len_bytes,
+                           int64_t absolute_capture_timestamp_ms) {
+    // TODO(bugs.webrtc.org/10739): Deprecate the old SendData and make this one
+    // pure virtual.
+    return SendData(frame_type, payload_type, timestamp, payload_data,
+                    payload_len_bytes);
+  }
+  virtual int32_t SendData(AudioFrameType frame_type,
+                           uint8_t payload_type,
+                           uint32_t timestamp,
+                           const uint8_t* payload_data,
+                           size_t payload_len_bytes) {
+    RTC_NOTREACHED() << "This method must be overridden, or not used.";
+    return -1;
+  }
 };
 
 class AudioCodingModule {
@@ -148,26 +152,6 @@ class AudioCodingModule {
   // TODO(minyue): Remove it when possible.
   virtual int SetPacketLossRate(int packet_loss_rate) = 0;
 
-  ///////////////////////////////////////////////////////////////////////////
-  //   (VAD) Voice Activity Detection
-  //
-
-  ///////////////////////////////////////////////////////////////////////////
-  // int32_t RegisterVADCallback()
-  // Call this method to register a callback function which is called
-  // any time that ACM encounters an empty frame. That is a frame which is
-  // recognized inactive. Depending on the codec WebRtc VAD or internal codec
-  // VAD is employed to identify a frame as active/inactive.
-  //
-  // Input:
-  //   -vad_callback        : pointer to a callback function.
-  //
-  // Return value:
-  //   -1 if failed to register the callback function.
-  //    0 if the callback function is registered successfully.
-  //
-  virtual int32_t RegisterVADCallback(ACMVADCallback* vad_callback) = 0;
-
   ///////////////////////////////////////////////////////////////////////////
   //   Receiver
   //
