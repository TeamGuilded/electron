From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Ciarlillo <alex.ciarlillo@gmail.com>
Date: Thu, 8 Sep 2022 20:34:32 -0400
Subject: limit hw encode to highest quality simulcast layer

To prevent taking too many NVENC encoers, we will only
use hardware encoding on the largest (highest quality)
spatial layer of a simulcast stream.

diff --git a/media/engine/simulcast_encoder_adapter.cc b/media/engine/simulcast_encoder_adapter.cc
index 4a53b8027c7468c2d5d5c318df05e86f549f637e..0130172a2ed36688614df617bfb499d3d8a30d9b 100644
--- a/media/engine/simulcast_encoder_adapter.cc
+++ b/media/engine/simulcast_encoder_adapter.cc
@@ -335,7 +335,8 @@ int SimulcastEncoderAdapter::InitEncode(
   std::unique_ptr<EncoderContext> encoder_context = FetchOrCreateEncoderContext(
       /*is_lowest_quality_stream=*/(
           is_legacy_singlecast ||
-          codec_.simulcastStream[lowest_quality_stream_idx].active));
+          codec_.simulcastStream[lowest_quality_stream_idx].active),
+          /*prefer_hardware_accel=*/lowest_quality_stream_idx == highest_quality_stream_idx);
   if (encoder_context == nullptr) {
     return WEBRTC_VIDEO_CODEC_MEMORY;
   }
@@ -389,7 +390,8 @@ int SimulcastEncoderAdapter::InitEncode(
 
     if (encoder_context == nullptr) {
       encoder_context = FetchOrCreateEncoderContext(
-          /*is_lowest_quality_stream=*/stream_idx == lowest_quality_stream_idx);
+          /*is_lowest_quality_stream=*/stream_idx == lowest_quality_stream_idx,
+          /*prefer_hardware_accel=*/stream_idx == highest_quality_stream_idx);
     }
     if (encoder_context == nullptr) {
       Release();
@@ -688,7 +690,7 @@ void SimulcastEncoderAdapter::DestroyStoredEncoders() {
 
 std::unique_ptr<SimulcastEncoderAdapter::EncoderContext>
 SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
-    bool is_lowest_quality_stream) const {
+    bool is_lowest_quality_stream, bool prefer_hardware_accel) const {
   bool prefer_temporal_support = fallback_encoder_factory_ != nullptr &&
                                  is_lowest_quality_stream &&
                                  prefer_temporal_support_on_base_layer_;
@@ -700,7 +702,7 @@ SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
       std::find_if(cached_encoder_contexts_.begin(),
                    cached_encoder_contexts_.end(), [&](auto& encoder_context) {
                      return encoder_context->prefer_temporal_support() ==
-                            prefer_temporal_support;
+                            prefer_temporal_support && encoder_context->PrimaryInfo().is_hardware_accelerated == prefer_hardware_accel;
                    });
 
   std::unique_ptr<SimulcastEncoderAdapter::EncoderContext> encoder_context;
@@ -721,7 +723,7 @@ SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
     VideoEncoder::EncoderInfo primary_info;
     VideoEncoder::EncoderInfo fallback_info;
 
-    if (primary_encoder != nullptr) {
+    if (primary_encoder != nullptr && prefer_hardware_accel) {
       primary_info = primary_encoder->GetEncoderInfo();
       fallback_info = primary_info;
 
@@ -853,7 +855,7 @@ VideoEncoder::EncoderInfo SimulcastEncoderAdapter::GetEncoderInfo() const {
     // Create one encoder and query it.
 
     std::unique_ptr<SimulcastEncoderAdapter::EncoderContext> encoder_context =
-        FetchOrCreateEncoderContext(/*is_lowest_quality_stream=*/true);
+        FetchOrCreateEncoderContext(/*is_lowest_quality_stream=*/true, /*prefer_hardware_accel=*/true);
     if (encoder_context == nullptr) {
       return encoder_info;
     }
diff --git a/media/engine/simulcast_encoder_adapter.h b/media/engine/simulcast_encoder_adapter.h
index ef8205e91af724cf6d96c16c42ee0aaafc2c602f..987467257ce5230b375fc5b1a626d87e1baec704 100644
--- a/media/engine/simulcast_encoder_adapter.h
+++ b/media/engine/simulcast_encoder_adapter.h
@@ -150,7 +150,7 @@ class RTC_EXPORT SimulcastEncoderAdapter : public VideoEncoder {
   // `cached_encoder_contexts_`. It's const because it's used from
   // const GetEncoderInfo().
   std::unique_ptr<EncoderContext> FetchOrCreateEncoderContext(
-      bool is_lowest_quality_stream) const;
+      bool is_lowest_quality_stream, bool prefer_hardware_accel) const;
 
   webrtc::VideoCodec MakeStreamCodec(const webrtc::VideoCodec& codec,
                                      int stream_idx,
