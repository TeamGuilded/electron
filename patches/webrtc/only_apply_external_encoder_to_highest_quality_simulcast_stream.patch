From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Ciarlillo <alex.ciarlillo@gmail.com>
Date: Mon, 29 Aug 2022 14:44:08 -0400
Subject: only apply external encoder to highest quality simulcast stream

Guilded Patch: limit hardware encoder instances by only using HW
encoding on the largest simulcast layer

diff --git a/media/engine/simulcast_encoder_adapter.cc b/media/engine/simulcast_encoder_adapter.cc
index e1dfc9460929235c2e9196ad561fe1a6adc66de4..e842e1d3f1f505c744a2c23ad51bd0aaaa0391d2 100644
--- a/media/engine/simulcast_encoder_adapter.cc
+++ b/media/engine/simulcast_encoder_adapter.cc
@@ -336,7 +336,7 @@ int SimulcastEncoderAdapter::InitEncode(
   std::unique_ptr<EncoderContext> encoder_context = FetchOrCreateEncoderContext(
       /*is_lowest_quality_stream=*/(
           is_legacy_singlecast ||
-          codec_.simulcastStream[lowest_quality_stream_idx].active));
+          codec_.simulcastStream[lowest_quality_stream_idx].active), /*prefer_hardware_accel=*/lowest_quality_stream_idx == highest_quality_stream_idx);
   if (encoder_context == nullptr) {
     return WEBRTC_VIDEO_CODEC_MEMORY;
   }
@@ -390,7 +390,8 @@ int SimulcastEncoderAdapter::InitEncode(
 
     if (encoder_context == nullptr) {
       encoder_context = FetchOrCreateEncoderContext(
-          /*is_lowest_quality_stream=*/stream_idx == lowest_quality_stream_idx);
+      /*is_lowest_quality_stream=*/stream_idx == lowest_quality_stream_idx,
+      /*prefer_hardware_accel=*/stream_idx == highest_quality_stream_idx);
     }
     if (encoder_context == nullptr) {
       Release();
@@ -689,7 +690,7 @@ void SimulcastEncoderAdapter::DestroyStoredEncoders() {
 
 std::unique_ptr<SimulcastEncoderAdapter::EncoderContext>
 SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
-    bool is_lowest_quality_stream) const {
+    bool is_lowest_quality_stream, bool prefer_hardware_accel) const {
   bool prefer_temporal_support = fallback_encoder_factory_ != nullptr &&
                                  is_lowest_quality_stream &&
                                  prefer_temporal_support_on_base_layer_;
@@ -697,11 +698,14 @@ SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
   // Toggling of `prefer_temporal_support` requires encoder recreation. Find
   // and reuse encoder with desired `prefer_temporal_support`. Otherwise, if
   // there is no such encoder in the cache, create a new instance.
+  // Guilded Patch:
+  // Similarly for prefering hardware encoding vs not, we only want to select
+  // a cached encoder that matches this preference
   auto encoder_context_iter =
       std::find_if(cached_encoder_contexts_.begin(),
                    cached_encoder_contexts_.end(), [&](auto& encoder_context) {
                      return encoder_context->prefer_temporal_support() ==
-                            prefer_temporal_support;
+                           prefer_temporal_support && encoder_context->PrimaryInfo().is_hardware_accelerated == prefer_hardware_accel;
                    });
 
   std::unique_ptr<SimulcastEncoderAdapter::EncoderContext> encoder_context;
@@ -709,40 +713,53 @@ SimulcastEncoderAdapter::FetchOrCreateEncoderContext(
     encoder_context = std::move(*encoder_context_iter);
     cached_encoder_contexts_.erase(encoder_context_iter);
   } else {
-    std::unique_ptr<VideoEncoder> primary_encoder =
-        primary_encoder_factory_->CreateVideoEncoder(video_format_);
+    std::unique_ptr<VideoEncoder> encoder;
+    // Guilded Patch:
+    // for the lower quality streams we will use the fallback (read: software) encoder
+    // as long as one was provided
+    if (!prefer_hardware_accel && fallback_encoder_factory_ != nullptr) {
+      encoder = fallback_encoder_factory_->CreateVideoEncoder(video_format_);
+      VideoEncoder::EncoderInfo primary_info = encoder->GetEncoderInfo();
+      VideoEncoder::EncoderInfo fallback_info = primary_info;
+
+      encoder_context = std::make_unique<SimulcastEncoderAdapter::EncoderContext>(
+        std::move(encoder), prefer_temporal_support, primary_info,
+        fallback_info);
 
-    std::unique_ptr<VideoEncoder> fallback_encoder;
-    if (fallback_encoder_factory_ != nullptr) {
-      fallback_encoder =
-          fallback_encoder_factory_->CreateVideoEncoder(video_format_);
-    }
+    } else {
+      std::unique_ptr<VideoEncoder> primary_encoder =
+        primary_encoder_factory_->CreateVideoEncoder(video_format_);
+      VideoEncoder::EncoderInfo primary_info = encoder->GetEncoderInfo();
+      VideoEncoder::EncoderInfo fallback_info = primary_info;
 
-    std::unique_ptr<VideoEncoder> encoder;
-    VideoEncoder::EncoderInfo primary_info;
-    VideoEncoder::EncoderInfo fallback_info;
+      std::unique_ptr<VideoEncoder> fallback_encoder;
+      if (fallback_encoder_factory_ != nullptr) {
+        fallback_encoder =
+            fallback_encoder_factory_->CreateVideoEncoder(video_format_);
+      }
 
-    if (primary_encoder != nullptr) {
-      primary_info = primary_encoder->GetEncoderInfo();
-      fallback_info = primary_info;
+      if (primary_encoder != nullptr) {
+        primary_info = primary_encoder->GetEncoderInfo();
+        fallback_info = primary_info;
 
-      if (fallback_encoder == nullptr) {
-        encoder = std::move(primary_encoder);
+        if (fallback_encoder == nullptr) {
+          encoder = std::move(primary_encoder);
+        } else {
+          encoder = CreateVideoEncoderSoftwareFallbackWrapper(
+              std::move(fallback_encoder), std::move(primary_encoder),
+              prefer_temporal_support);
+        }
+      } else if (fallback_encoder != nullptr) {
+        RTC_LOG(LS_WARNING) << "Failed to create primary " << video_format_.name
+                            << " encoder. Use fallback encoder.";
+        fallback_info = fallback_encoder->GetEncoderInfo();
+        primary_info = fallback_info;
+        encoder = std::move(fallback_encoder);
       } else {
-        encoder = CreateVideoEncoderSoftwareFallbackWrapper(
-            std::move(fallback_encoder), std::move(primary_encoder),
-            prefer_temporal_support);
+        RTC_LOG(LS_ERROR) << "Failed to create primary and fallback "
+                          << video_format_.name << " encoders.";
+        return nullptr;
       }
-    } else if (fallback_encoder != nullptr) {
-      RTC_LOG(LS_WARNING) << "Failed to create primary " << video_format_.name
-                          << " encoder. Use fallback encoder.";
-      fallback_info = fallback_encoder->GetEncoderInfo();
-      primary_info = fallback_info;
-      encoder = std::move(fallback_encoder);
-    } else {
-      RTC_LOG(LS_ERROR) << "Failed to create primary and fallback "
-                        << video_format_.name << " encoders.";
-      return nullptr;
     }
 
     encoder_context = std::make_unique<SimulcastEncoderAdapter::EncoderContext>(
@@ -854,7 +871,7 @@ VideoEncoder::EncoderInfo SimulcastEncoderAdapter::GetEncoderInfo() const {
     // Create one encoder and query it.
 
     std::unique_ptr<SimulcastEncoderAdapter::EncoderContext> encoder_context =
-        FetchOrCreateEncoderContext(/*is_lowest_quality_stream=*/true);
+        FetchOrCreateEncoderContext(/*is_lowest_quality_stream=*/true,/*prefer_hardware_accel=*/true);
     if (encoder_context == nullptr) {
       return encoder_info;
     }
diff --git a/media/engine/simulcast_encoder_adapter.h b/media/engine/simulcast_encoder_adapter.h
index e6b6badbe54f7ed2baf8227e299e87df7fb1aab1..9382ab66644a001c5b39f7057e7c1d9b9da5cb5a 100644
--- a/media/engine/simulcast_encoder_adapter.h
+++ b/media/engine/simulcast_encoder_adapter.h
@@ -150,7 +150,7 @@ class RTC_EXPORT SimulcastEncoderAdapter : public VideoEncoder {
   // `cached_encoder_contexts_`. It's const because it's used from
   // const GetEncoderInfo().
   std::unique_ptr<EncoderContext> FetchOrCreateEncoderContext(
-      bool is_lowest_quality_stream) const;
+      bool is_lowest_quality_stream, bool prefer_hardware_accel) const;
 
   webrtc::VideoCodec MakeStreamCodec(const webrtc::VideoCodec& codec,
                                      int stream_idx,
